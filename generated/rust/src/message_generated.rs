// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod protocol {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CREATE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CREATE_TYPE: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CREATE_TYPE: [CreateType; 2] = [
  CreateType::NONE,
  CreateType::CreatePlan,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CreateType(pub u8);
#[allow(non_upper_case_globals)]
impl CreateType {
  pub const NONE: Self = Self(0);
  pub const CreatePlan: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::CreatePlan,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::CreatePlan => Some("CreatePlan"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CreateType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CreateType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CreateType {
    type Output = CreateType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CreateType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CreateType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CreateType {}
pub struct CreateTypeUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FILTER_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FILTER_TYPE: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FILTER_TYPE: [FilterType; 2] = [
  FilterType::NONE,
  FilterType::ByName,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FilterType(pub u8);
#[allow(non_upper_case_globals)]
impl FilterType {
  pub const NONE: Self = Self(0);
  pub const ByName: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::ByName,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::ByName => Some("ByName"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FilterType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FilterType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for FilterType {
    type Output = FilterType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FilterType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FilterType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FilterType {}
pub struct FilterTypeUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GET_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GET_TYPE: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GET_TYPE: [GetType; 3] = [
  GetType::NONE,
  GetType::GetPlans,
  GetType::GetPlan,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GetType(pub u8);
#[allow(non_upper_case_globals)]
impl GetType {
  pub const NONE: Self = Self(0);
  pub const GetPlans: Self = Self(1);
  pub const GetPlan: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::GetPlans,
    Self::GetPlan,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::GetPlans => Some("GetPlans"),
      Self::GetPlan => Some("GetPlan"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GetType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GetType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GetType {
    type Output = GetType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GetType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GetType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GetType {}
pub struct GetTypeUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VALUE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VALUE: u8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VALUE: [Value; 7] = [
  Value::NONE,
  Value::Null,
  Value::String,
  Value::Integer,
  Value::Float,
  Value::List,
  Value::Document,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Value(pub u8);
#[allow(non_upper_case_globals)]
impl Value {
  pub const NONE: Self = Self(0);
  pub const Null: Self = Self(1);
  pub const String: Self = Self(2);
  pub const Integer: Self = Self(3);
  pub const Float: Self = Self(4);
  pub const List: Self = Self(5);
  pub const Document: Self = Self(6);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Null,
    Self::String,
    Self::Integer,
    Self::Float,
    Self::List,
    Self::Document,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Null => Some("Null"),
      Self::String => Some("String"),
      Self::Integer => Some("Integer"),
      Self::Float => Some("Float"),
      Self::List => Some("List"),
      Self::Document => Some("Document"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Value {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Value {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Value {
    type Output = Value;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Value {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Value {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Value {}
pub struct ValueUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PAYLOAD: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PAYLOAD: u8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PAYLOAD: [Payload; 6] = [
  Payload::NONE,
  Payload::Create,
  Payload::Get,
  Payload::Values,
  Payload::Catalog,
  Payload::Register,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Payload(pub u8);
#[allow(non_upper_case_globals)]
impl Payload {
  pub const NONE: Self = Self(0);
  pub const Create: Self = Self(1);
  pub const Get: Self = Self(2);
  pub const Values: Self = Self(3);
  pub const Catalog: Self = Self(4);
  pub const Register: Self = Self(5);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Create,
    Self::Get,
    Self::Values,
    Self::Catalog,
    Self::Register,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Create => Some("Create"),
      Self::Get => Some("Get"),
      Self::Values => Some("Values"),
      Self::Catalog => Some("Catalog"),
      Self::Register => Some("Register"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Payload {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Payload {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Payload {
    type Output = Payload;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Payload {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Payload {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Payload {}
pub struct PayloadUnionTableOffset {}

pub enum RegisterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Register<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Register<'a> {
  type Inner = Register<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Register<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CATALOG: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Register { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RegisterArgs<'args>
  ) -> flatbuffers::WIPOffset<Register<'bldr>> {
    let mut builder = RegisterBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.catalog { builder.add_catalog(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<i64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Register::VT_ID, None)}
  }
  #[inline]
  pub fn catalog(&self) -> Option<Catalog<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Catalog>>(Register::VT_CATALOG, None)}
  }
}

impl flatbuffers::Verifiable for Register<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Catalog>>("catalog", Self::VT_CATALOG, false)?
     .finish();
    Ok(())
  }
}
pub struct RegisterArgs<'a> {
    pub id: Option<i64>,
    pub catalog: Option<flatbuffers::WIPOffset<Catalog<'a>>>,
}
impl<'a> Default for RegisterArgs<'a> {
  #[inline]
  fn default() -> Self {
    RegisterArgs {
      id: None,
      catalog: None,
    }
  }
}

pub struct RegisterBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RegisterBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: i64) {
    self.fbb_.push_slot_always::<i64>(Register::VT_ID, id);
  }
  #[inline]
  pub fn add_catalog(&mut self, catalog: flatbuffers::WIPOffset<Catalog<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Catalog>>(Register::VT_CATALOG, catalog);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RegisterBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RegisterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Register<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Register<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Register");
      ds.field("id", &self.id());
      ds.field("catalog", &self.catalog());
      ds.finish()
  }
}
pub enum CreateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Create<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Create<'a> {
  type Inner = Create<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Create<'a> {
  pub const VT_CREATE_TYPE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_CREATE_TYPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Create { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CreateArgs
  ) -> flatbuffers::WIPOffset<Create<'bldr>> {
    let mut builder = CreateBuilder::new(_fbb);
    if let Some(x) = args.create_type { builder.add_create_type(x); }
    builder.add_create_type_type(args.create_type_type);
    builder.finish()
  }


  #[inline]
  pub fn create_type_type(&self) -> CreateType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CreateType>(Create::VT_CREATE_TYPE_TYPE, Some(CreateType::NONE)).unwrap()}
  }
  #[inline]
  pub fn create_type(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Create::VT_CREATE_TYPE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn create_type_as_create_plan(&self) -> Option<CreatePlan<'a>> {
    if self.create_type_type() == CreateType::CreatePlan {
      self.create_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CreatePlan::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Create<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<CreateType, _>("create_type_type", Self::VT_CREATE_TYPE_TYPE, "create_type", Self::VT_CREATE_TYPE, false, |key, v, pos| {
        match key {
          CreateType::CreatePlan => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CreatePlan>>("CreateType::CreatePlan", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct CreateArgs {
    pub create_type_type: CreateType,
    pub create_type: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for CreateArgs {
  #[inline]
  fn default() -> Self {
    CreateArgs {
      create_type_type: CreateType::NONE,
      create_type: None,
    }
  }
}

pub struct CreateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CreateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_create_type_type(&mut self, create_type_type: CreateType) {
    self.fbb_.push_slot::<CreateType>(Create::VT_CREATE_TYPE_TYPE, create_type_type, CreateType::NONE);
  }
  #[inline]
  pub fn add_create_type(&mut self, create_type: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Create::VT_CREATE_TYPE, create_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CreateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CreateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Create<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Create<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Create");
      ds.field("create_type_type", &self.create_type_type());
      match self.create_type_type() {
        CreateType::CreatePlan => {
          if let Some(x) = self.create_type_as_create_plan() {
            ds.field("create_type", &x)
          } else {
            ds.field("create_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("create_type", &x)
        },
      };
      ds.finish()
  }
}
pub enum CreatePlanOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CreatePlan<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreatePlan<'a> {
  type Inner = CreatePlan<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CreatePlan<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_PLAN: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CreatePlan { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CreatePlanArgs<'args>
  ) -> flatbuffers::WIPOffset<CreatePlan<'bldr>> {
    let mut builder = CreatePlanBuilder::new(_fbb);
    if let Some(x) = args.plan { builder.add_plan(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CreatePlan::VT_NAME, None)}
  }
  #[inline]
  pub fn plan(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CreatePlan::VT_PLAN, None)}
  }
}

impl flatbuffers::Verifiable for CreatePlan<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("plan", Self::VT_PLAN, false)?
     .finish();
    Ok(())
  }
}
pub struct CreatePlanArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub plan: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CreatePlanArgs<'a> {
  #[inline]
  fn default() -> Self {
    CreatePlanArgs {
      name: None,
      plan: None,
    }
  }
}

pub struct CreatePlanBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CreatePlanBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreatePlan::VT_NAME, name);
  }
  #[inline]
  pub fn add_plan(&mut self, plan: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreatePlan::VT_PLAN, plan);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CreatePlanBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CreatePlanBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreatePlan<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CreatePlan<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CreatePlan");
      ds.field("name", &self.name());
      ds.field("plan", &self.plan());
      ds.finish()
  }
}
pub enum ByNameOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ByName<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ByName<'a> {
  type Inner = ByName<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ByName<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ByName { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ByNameArgs<'args>
  ) -> flatbuffers::WIPOffset<ByName<'bldr>> {
    let mut builder = ByNameBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ByName::VT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for ByName<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct ByNameArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ByNameArgs<'a> {
  #[inline]
  fn default() -> Self {
    ByNameArgs {
      name: None,
    }
  }
}

pub struct ByNameBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ByNameBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ByName::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ByNameBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ByNameBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ByName<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ByName<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ByName");
      ds.field("name", &self.name());
      ds.finish()
  }
}
pub enum FilterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Filter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Filter<'a> {
  type Inner = Filter<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Filter<'a> {
  pub const VT_FILTER_TYPE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_FILTER_TYPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Filter { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FilterArgs
  ) -> flatbuffers::WIPOffset<Filter<'bldr>> {
    let mut builder = FilterBuilder::new(_fbb);
    if let Some(x) = args.filter_type { builder.add_filter_type(x); }
    builder.add_filter_type_type(args.filter_type_type);
    builder.finish()
  }


  #[inline]
  pub fn filter_type_type(&self) -> FilterType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FilterType>(Filter::VT_FILTER_TYPE_TYPE, Some(FilterType::NONE)).unwrap()}
  }
  #[inline]
  pub fn filter_type(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Filter::VT_FILTER_TYPE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn filter_type_as_by_name(&self) -> Option<ByName<'a>> {
    if self.filter_type_type() == FilterType::ByName {
      self.filter_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ByName::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Filter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<FilterType, _>("filter_type_type", Self::VT_FILTER_TYPE_TYPE, "filter_type", Self::VT_FILTER_TYPE, false, |key, v, pos| {
        match key {
          FilterType::ByName => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ByName>>("FilterType::ByName", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct FilterArgs {
    pub filter_type_type: FilterType,
    pub filter_type: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for FilterArgs {
  #[inline]
  fn default() -> Self {
    FilterArgs {
      filter_type_type: FilterType::NONE,
      filter_type: None,
    }
  }
}

pub struct FilterBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FilterBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_filter_type_type(&mut self, filter_type_type: FilterType) {
    self.fbb_.push_slot::<FilterType>(Filter::VT_FILTER_TYPE_TYPE, filter_type_type, FilterType::NONE);
  }
  #[inline]
  pub fn add_filter_type(&mut self, filter_type: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Filter::VT_FILTER_TYPE, filter_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FilterBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FilterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Filter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Filter<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Filter");
      ds.field("filter_type_type", &self.filter_type_type());
      match self.filter_type_type() {
        FilterType::ByName => {
          if let Some(x) = self.filter_type_as_by_name() {
            ds.field("filter_type", &x)
          } else {
            ds.field("filter_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("filter_type", &x)
        },
      };
      ds.finish()
  }
}
pub enum GetPlansOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetPlans<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetPlans<'a> {
  type Inner = GetPlans<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetPlans<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetPlans { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetPlansArgs<'args>
  ) -> flatbuffers::WIPOffset<GetPlans<'bldr>> {
    let mut builder = GetPlansBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<Filter<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Filter>>(GetPlans::VT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for GetPlans<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Filter>>("name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct GetPlansArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<Filter<'a>>>,
}
impl<'a> Default for GetPlansArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetPlansArgs {
      name: None,
    }
  }
}

pub struct GetPlansBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetPlansBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<Filter<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Filter>>(GetPlans::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetPlansBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetPlansBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetPlans<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetPlans<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetPlans");
      ds.field("name", &self.name());
      ds.finish()
  }
}
pub enum GetPlanOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetPlan<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetPlan<'a> {
  type Inner = GetPlan<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetPlan<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetPlan { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetPlanArgs
  ) -> flatbuffers::WIPOffset<GetPlan<'bldr>> {
    let mut builder = GetPlanBuilder::new(_fbb);
    builder.add_id(args.id);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GetPlan::VT_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GetPlan<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GetPlanArgs {
    pub id: u64,
}
impl<'a> Default for GetPlanArgs {
  #[inline]
  fn default() -> Self {
    GetPlanArgs {
      id: 0,
    }
  }
}

pub struct GetPlanBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetPlanBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(GetPlan::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetPlanBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetPlanBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetPlan<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetPlan<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetPlan");
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum GetOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Get<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Get<'a> {
  type Inner = Get<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Get<'a> {
  pub const VT_GET_TYPE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_GET_TYPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Get { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetArgs
  ) -> flatbuffers::WIPOffset<Get<'bldr>> {
    let mut builder = GetBuilder::new(_fbb);
    if let Some(x) = args.get_type { builder.add_get_type(x); }
    builder.add_get_type_type(args.get_type_type);
    builder.finish()
  }


  #[inline]
  pub fn get_type_type(&self) -> GetType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GetType>(Get::VT_GET_TYPE_TYPE, Some(GetType::NONE)).unwrap()}
  }
  #[inline]
  pub fn get_type(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Get::VT_GET_TYPE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn get_type_as_get_plans(&self) -> Option<GetPlans<'a>> {
    if self.get_type_type() == GetType::GetPlans {
      self.get_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GetPlans::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn get_type_as_get_plan(&self) -> Option<GetPlan<'a>> {
    if self.get_type_type() == GetType::GetPlan {
      self.get_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GetPlan::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Get<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<GetType, _>("get_type_type", Self::VT_GET_TYPE_TYPE, "get_type", Self::VT_GET_TYPE, false, |key, v, pos| {
        match key {
          GetType::GetPlans => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetPlans>>("GetType::GetPlans", pos),
          GetType::GetPlan => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetPlan>>("GetType::GetPlan", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct GetArgs {
    pub get_type_type: GetType,
    pub get_type: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for GetArgs {
  #[inline]
  fn default() -> Self {
    GetArgs {
      get_type_type: GetType::NONE,
      get_type: None,
    }
  }
}

pub struct GetBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_get_type_type(&mut self, get_type_type: GetType) {
    self.fbb_.push_slot::<GetType>(Get::VT_GET_TYPE_TYPE, get_type_type, GetType::NONE);
  }
  #[inline]
  pub fn add_get_type(&mut self, get_type: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Get::VT_GET_TYPE, get_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Get<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Get<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Get");
      ds.field("get_type_type", &self.get_type_type());
      match self.get_type_type() {
        GetType::GetPlans => {
          if let Some(x) = self.get_type_as_get_plans() {
            ds.field("get_type", &x)
          } else {
            ds.field("get_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GetType::GetPlan => {
          if let Some(x) = self.get_type_as_get_plan() {
            ds.field("get_type", &x)
          } else {
            ds.field("get_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("get_type", &x)
        },
      };
      ds.finish()
  }
}
pub enum CatalogOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Catalog<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Catalog<'a> {
  type Inner = Catalog<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Catalog<'a> {
  pub const VT_PLANS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Catalog { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CatalogArgs<'args>
  ) -> flatbuffers::WIPOffset<Catalog<'bldr>> {
    let mut builder = CatalogBuilder::new(_fbb);
    if let Some(x) = args.plans { builder.add_plans(x); }
    builder.finish()
  }


  #[inline]
  pub fn plans(&self) -> Option<Plans<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Plans>>(Catalog::VT_PLANS, None)}
  }
}

impl flatbuffers::Verifiable for Catalog<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Plans>>("plans", Self::VT_PLANS, false)?
     .finish();
    Ok(())
  }
}
pub struct CatalogArgs<'a> {
    pub plans: Option<flatbuffers::WIPOffset<Plans<'a>>>,
}
impl<'a> Default for CatalogArgs<'a> {
  #[inline]
  fn default() -> Self {
    CatalogArgs {
      plans: None,
    }
  }
}

pub struct CatalogBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CatalogBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_plans(&mut self, plans: flatbuffers::WIPOffset<Plans<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Plans>>(Catalog::VT_PLANS, plans);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CatalogBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CatalogBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Catalog<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Catalog<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Catalog");
      ds.field("plans", &self.plans());
      ds.finish()
  }
}
pub enum PlanOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Plan<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Plan<'a> {
  type Inner = Plan<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Plan<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_TEMPLATE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Plan { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PlanArgs<'args>
  ) -> flatbuffers::WIPOffset<Plan<'bldr>> {
    let mut builder = PlanBuilder::new(_fbb);
    if let Some(x) = args.template { builder.add_template(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Plan::VT_NAME, None)}
  }
  #[inline]
  pub fn template(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Plan::VT_TEMPLATE, None)}
  }
}

impl flatbuffers::Verifiable for Plan<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("template", Self::VT_TEMPLATE, false)?
     .finish();
    Ok(())
  }
}
pub struct PlanArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub template: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PlanArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlanArgs {
      name: None,
      template: None,
    }
  }
}

pub struct PlanBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PlanBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Plan::VT_NAME, name);
  }
  #[inline]
  pub fn add_template(&mut self, template: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Plan::VT_TEMPLATE, template);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PlanBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PlanBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Plan<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Plan<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Plan");
      ds.field("name", &self.name());
      ds.field("template", &self.template());
      ds.finish()
  }
}
pub enum PlansOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Plans<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Plans<'a> {
  type Inner = Plans<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Plans<'a> {
  pub const VT_PLANS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Plans { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PlansArgs<'args>
  ) -> flatbuffers::WIPOffset<Plans<'bldr>> {
    let mut builder = PlansBuilder::new(_fbb);
    if let Some(x) = args.plans { builder.add_plans(x); }
    builder.finish()
  }


  #[inline]
  pub fn plans(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Plan<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Plan>>>>(Plans::VT_PLANS, None)}
  }
}

impl flatbuffers::Verifiable for Plans<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Plan>>>>("plans", Self::VT_PLANS, false)?
     .finish();
    Ok(())
  }
}
pub struct PlansArgs<'a> {
    pub plans: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Plan<'a>>>>>,
}
impl<'a> Default for PlansArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlansArgs {
      plans: None,
    }
  }
}

pub struct PlansBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PlansBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_plans(&mut self, plans: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Plan<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Plans::VT_PLANS, plans);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PlansBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PlansBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Plans<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Plans<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Plans");
      ds.field("plans", &self.plans());
      ds.finish()
  }
}
pub enum NullOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Null<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Null<'a> {
  type Inner = Null<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Null<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Null { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args NullArgs
  ) -> flatbuffers::WIPOffset<Null<'bldr>> {
    let mut builder = NullBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for Null<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct NullArgs {
}
impl<'a> Default for NullArgs {
  #[inline]
  fn default() -> Self {
    NullArgs {
    }
  }
}

pub struct NullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NullBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Null<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Null<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Null");
      ds.finish()
  }
}
pub enum StringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct String<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for String<'a> {
  type Inner = String<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> String<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    String { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StringArgs<'args>
  ) -> flatbuffers::WIPOffset<String<'bldr>> {
    let mut builder = StringBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(String::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for String<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct StringArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StringArgs<'a> {
  #[inline]
  fn default() -> Self {
    StringArgs {
      data: None,
    }
  }
}

pub struct StringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StringBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(String::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StringBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StringBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<String<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for String<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("String");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum IntegerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Integer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Integer<'a> {
  type Inner = Integer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Integer<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Integer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IntegerArgs
  ) -> flatbuffers::WIPOffset<Integer<'bldr>> {
    let mut builder = IntegerBuilder::new(_fbb);
    builder.add_data(args.data);
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Integer::VT_DATA, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Integer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct IntegerArgs {
    pub data: u64,
}
impl<'a> Default for IntegerArgs {
  #[inline]
  fn default() -> Self {
    IntegerArgs {
      data: 0,
    }
  }
}

pub struct IntegerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IntegerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data(&mut self, data: u64) {
    self.fbb_.push_slot::<u64>(Integer::VT_DATA, data, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IntegerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IntegerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Integer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Integer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Integer");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum FloatOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Float<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Float<'a> {
  type Inner = Float<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Float<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Float { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FloatArgs
  ) -> flatbuffers::WIPOffset<Float<'bldr>> {
    let mut builder = FloatBuilder::new(_fbb);
    builder.add_data(args.data);
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Float::VT_DATA, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Float<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct FloatArgs {
    pub data: f32,
}
impl<'a> Default for FloatArgs {
  #[inline]
  fn default() -> Self {
    FloatArgs {
      data: 0.0,
    }
  }
}

pub struct FloatBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FloatBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data(&mut self, data: f32) {
    self.fbb_.push_slot::<f32>(Float::VT_DATA, data, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FloatBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FloatBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Float<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Float<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Float");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum ValueWrapperOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ValueWrapper<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ValueWrapper<'a> {
  type Inner = ValueWrapper<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ValueWrapper<'a> {
  pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ValueWrapper { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ValueWrapperArgs
  ) -> flatbuffers::WIPOffset<ValueWrapper<'bldr>> {
    let mut builder = ValueWrapperBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.add_data_type(args.data_type);
    builder.finish()
  }


  #[inline]
  pub fn data_type(&self) -> Value {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Value>(ValueWrapper::VT_DATA_TYPE, Some(Value::NONE)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ValueWrapper::VT_DATA, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_null(&self) -> Option<Null<'a>> {
    if self.data_type() == Value::Null {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Null::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_string(&self) -> Option<String<'a>> {
    if self.data_type() == Value::String {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { String::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_integer(&self) -> Option<Integer<'a>> {
    if self.data_type() == Value::Integer {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Integer::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_float(&self) -> Option<Float<'a>> {
    if self.data_type() == Value::Float {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Float::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_list(&self) -> Option<List<'a>> {
    if self.data_type() == Value::List {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { List::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_document(&self) -> Option<Document<'a>> {
    if self.data_type() == Value::Document {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Document::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for ValueWrapper<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Value, _>("data_type", Self::VT_DATA_TYPE, "data", Self::VT_DATA, false, |key, v, pos| {
        match key {
          Value::Null => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Null>>("Value::Null", pos),
          Value::String => v.verify_union_variant::<flatbuffers::ForwardsUOffset<String>>("Value::String", pos),
          Value::Integer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Integer>>("Value::Integer", pos),
          Value::Float => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Float>>("Value::Float", pos),
          Value::List => v.verify_union_variant::<flatbuffers::ForwardsUOffset<List>>("Value::List", pos),
          Value::Document => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Document>>("Value::Document", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct ValueWrapperArgs {
    pub data_type: Value,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ValueWrapperArgs {
  #[inline]
  fn default() -> Self {
    ValueWrapperArgs {
      data_type: Value::NONE,
      data: None,
    }
  }
}

pub struct ValueWrapperBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ValueWrapperBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data_type(&mut self, data_type: Value) {
    self.fbb_.push_slot::<Value>(ValueWrapper::VT_DATA_TYPE, data_type, Value::NONE);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ValueWrapper::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ValueWrapperBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ValueWrapperBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ValueWrapper<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ValueWrapper<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ValueWrapper");
      ds.field("data_type", &self.data_type());
      match self.data_type() {
        Value::Null => {
          if let Some(x) = self.data_as_null() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::String => {
          if let Some(x) = self.data_as_string() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Integer => {
          if let Some(x) = self.data_as_integer() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Float => {
          if let Some(x) = self.data_as_float() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::List => {
          if let Some(x) = self.data_as_list() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Document => {
          if let Some(x) = self.data_as_document() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("data", &x)
        },
      };
      ds.finish()
  }
}
pub enum ListOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct List<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for List<'a> {
  type Inner = List<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> List<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    List { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ListArgs<'args>
  ) -> flatbuffers::WIPOffset<List<'bldr>> {
    let mut builder = ListBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueWrapper<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueWrapper>>>>(List::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for List<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ValueWrapper>>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct ListArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueWrapper<'a>>>>>,
}
impl<'a> Default for ListArgs<'a> {
  #[inline]
  fn default() -> Self {
    ListArgs {
      data: None,
    }
  }
}

pub struct ListBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ListBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ValueWrapper<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(List::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ListBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ListBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<List<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for List<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("List");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum KeyValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct KeyValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KeyValue<'a> {
  type Inner = KeyValue<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KeyValue<'a> {
  pub const VT_KEY_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_KEY: flatbuffers::VOffsetT = 6;
  pub const VT_VALUES_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_VALUES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KeyValue { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KeyValueArgs
  ) -> flatbuffers::WIPOffset<KeyValue<'bldr>> {
    let mut builder = KeyValueBuilder::new(_fbb);
    if let Some(x) = args.values { builder.add_values(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.add_values_type(args.values_type);
    builder.add_key_type(args.key_type);
    builder.finish()
  }


  #[inline]
  pub fn key_type(&self) -> Value {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Value>(KeyValue::VT_KEY_TYPE, Some(Value::NONE)).unwrap()}
  }
  #[inline]
  pub fn key(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(KeyValue::VT_KEY, None)}
  }
  #[inline]
  pub fn values_type(&self) -> Value {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Value>(KeyValue::VT_VALUES_TYPE, Some(Value::NONE)).unwrap()}
  }
  #[inline]
  pub fn values(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(KeyValue::VT_VALUES, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn key_as_null(&self) -> Option<Null<'a>> {
    if self.key_type() == Value::Null {
      self.key().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Null::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn key_as_string(&self) -> Option<String<'a>> {
    if self.key_type() == Value::String {
      self.key().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { String::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn key_as_integer(&self) -> Option<Integer<'a>> {
    if self.key_type() == Value::Integer {
      self.key().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Integer::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn key_as_float(&self) -> Option<Float<'a>> {
    if self.key_type() == Value::Float {
      self.key().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Float::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn key_as_list(&self) -> Option<List<'a>> {
    if self.key_type() == Value::List {
      self.key().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { List::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn key_as_document(&self) -> Option<Document<'a>> {
    if self.key_type() == Value::Document {
      self.key().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Document::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn values_as_null(&self) -> Option<Null<'a>> {
    if self.values_type() == Value::Null {
      self.values().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Null::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn values_as_string(&self) -> Option<String<'a>> {
    if self.values_type() == Value::String {
      self.values().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { String::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn values_as_integer(&self) -> Option<Integer<'a>> {
    if self.values_type() == Value::Integer {
      self.values().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Integer::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn values_as_float(&self) -> Option<Float<'a>> {
    if self.values_type() == Value::Float {
      self.values().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Float::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn values_as_list(&self) -> Option<List<'a>> {
    if self.values_type() == Value::List {
      self.values().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { List::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn values_as_document(&self) -> Option<Document<'a>> {
    if self.values_type() == Value::Document {
      self.values().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Document::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for KeyValue<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Value, _>("key_type", Self::VT_KEY_TYPE, "key", Self::VT_KEY, false, |key, v, pos| {
        match key {
          Value::Null => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Null>>("Value::Null", pos),
          Value::String => v.verify_union_variant::<flatbuffers::ForwardsUOffset<String>>("Value::String", pos),
          Value::Integer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Integer>>("Value::Integer", pos),
          Value::Float => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Float>>("Value::Float", pos),
          Value::List => v.verify_union_variant::<flatbuffers::ForwardsUOffset<List>>("Value::List", pos),
          Value::Document => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Document>>("Value::Document", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Value, _>("values_type", Self::VT_VALUES_TYPE, "values", Self::VT_VALUES, false, |key, v, pos| {
        match key {
          Value::Null => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Null>>("Value::Null", pos),
          Value::String => v.verify_union_variant::<flatbuffers::ForwardsUOffset<String>>("Value::String", pos),
          Value::Integer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Integer>>("Value::Integer", pos),
          Value::Float => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Float>>("Value::Float", pos),
          Value::List => v.verify_union_variant::<flatbuffers::ForwardsUOffset<List>>("Value::List", pos),
          Value::Document => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Document>>("Value::Document", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct KeyValueArgs {
    pub key_type: Value,
    pub key: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub values_type: Value,
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for KeyValueArgs {
  #[inline]
  fn default() -> Self {
    KeyValueArgs {
      key_type: Value::NONE,
      key: None,
      values_type: Value::NONE,
      values: None,
    }
  }
}

pub struct KeyValueBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KeyValueBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key_type(&mut self, key_type: Value) {
    self.fbb_.push_slot::<Value>(KeyValue::VT_KEY_TYPE, key_type, Value::NONE);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_KEY, key);
  }
  #[inline]
  pub fn add_values_type(&mut self, values_type: Value) {
    self.fbb_.push_slot::<Value>(KeyValue::VT_VALUES_TYPE, values_type, Value::NONE);
  }
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_VALUES, values);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KeyValueBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KeyValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KeyValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KeyValue<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KeyValue");
      ds.field("key_type", &self.key_type());
      match self.key_type() {
        Value::Null => {
          if let Some(x) = self.key_as_null() {
            ds.field("key", &x)
          } else {
            ds.field("key", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::String => {
          if let Some(x) = self.key_as_string() {
            ds.field("key", &x)
          } else {
            ds.field("key", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Integer => {
          if let Some(x) = self.key_as_integer() {
            ds.field("key", &x)
          } else {
            ds.field("key", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Float => {
          if let Some(x) = self.key_as_float() {
            ds.field("key", &x)
          } else {
            ds.field("key", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::List => {
          if let Some(x) = self.key_as_list() {
            ds.field("key", &x)
          } else {
            ds.field("key", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Document => {
          if let Some(x) = self.key_as_document() {
            ds.field("key", &x)
          } else {
            ds.field("key", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("key", &x)
        },
      };
      ds.field("values_type", &self.values_type());
      match self.values_type() {
        Value::Null => {
          if let Some(x) = self.values_as_null() {
            ds.field("values", &x)
          } else {
            ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::String => {
          if let Some(x) = self.values_as_string() {
            ds.field("values", &x)
          } else {
            ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Integer => {
          if let Some(x) = self.values_as_integer() {
            ds.field("values", &x)
          } else {
            ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Float => {
          if let Some(x) = self.values_as_float() {
            ds.field("values", &x)
          } else {
            ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::List => {
          if let Some(x) = self.values_as_list() {
            ds.field("values", &x)
          } else {
            ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Document => {
          if let Some(x) = self.values_as_document() {
            ds.field("values", &x)
          } else {
            ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("values", &x)
        },
      };
      ds.finish()
  }
}
pub enum DocumentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Document<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Document<'a> {
  type Inner = Document<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Document<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Document { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DocumentArgs<'args>
  ) -> flatbuffers::WIPOffset<Document<'bldr>> {
    let mut builder = DocumentBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>>>(Document::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for Document<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct DocumentArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>,
}
impl<'a> Default for DocumentArgs<'a> {
  #[inline]
  fn default() -> Self {
    DocumentArgs {
      data: None,
    }
  }
}

pub struct DocumentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DocumentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Document::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DocumentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DocumentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Document<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Document<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Document");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum ValuesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Values<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Values<'a> {
  type Inner = Values<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Values<'a> {
  pub const VT_VALUES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Values { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ValuesArgs<'args>
  ) -> flatbuffers::WIPOffset<Values<'bldr>> {
    let mut builder = ValuesBuilder::new(_fbb);
    if let Some(x) = args.values { builder.add_values(x); }
    builder.finish()
  }


  #[inline]
  pub fn values(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueWrapper<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueWrapper>>>>(Values::VT_VALUES, None)}
  }
}

impl flatbuffers::Verifiable for Values<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ValueWrapper>>>>("values", Self::VT_VALUES, false)?
     .finish();
    Ok(())
  }
}
pub struct ValuesArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueWrapper<'a>>>>>,
}
impl<'a> Default for ValuesArgs<'a> {
  #[inline]
  fn default() -> Self {
    ValuesArgs {
      values: None,
    }
  }
}

pub struct ValuesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ValuesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ValueWrapper<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Values::VT_VALUES, values);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ValuesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ValuesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Values<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Values<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Values");
      ds.field("values", &self.values());
      ds.finish()
  }
}
pub enum StatusOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Status<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Status<'a> {
  type Inner = Status<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Status<'a> {
  pub const VT_MSG: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Status { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StatusArgs<'args>
  ) -> flatbuffers::WIPOffset<Status<'bldr>> {
    let mut builder = StatusBuilder::new(_fbb);
    if let Some(x) = args.msg { builder.add_msg(x); }
    builder.finish()
  }


  #[inline]
  pub fn msg(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Status::VT_MSG, None)}
  }
}

impl flatbuffers::Verifiable for Status<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msg", Self::VT_MSG, false)?
     .finish();
    Ok(())
  }
}
pub struct StatusArgs<'a> {
    pub msg: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StatusArgs<'a> {
  #[inline]
  fn default() -> Self {
    StatusArgs {
      msg: None,
    }
  }
}

pub struct StatusBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StatusBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_msg(&mut self, msg: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Status::VT_MSG, msg);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StatusBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StatusBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Status<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Status<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Status");
      ds.field("msg", &self.msg());
      ds.finish()
  }
}
pub enum MessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Message<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Message<'a> {
  type Inner = Message<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Message<'a> {
  pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;
  pub const VT_STATUS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Message { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MessageArgs<'args>
  ) -> flatbuffers::WIPOffset<Message<'bldr>> {
    let mut builder = MessageBuilder::new(_fbb);
    if let Some(x) = args.status { builder.add_status(x); }
    if let Some(x) = args.data { builder.add_data(x); }
    builder.add_data_type(args.data_type);
    builder.finish()
  }


  #[inline]
  pub fn data_type(&self) -> Payload {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Payload>(Message::VT_DATA_TYPE, Some(Payload::NONE)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Message::VT_DATA, None)}
  }
  #[inline]
  pub fn status(&self) -> Option<Status<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Status>>(Message::VT_STATUS, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_create(&self) -> Option<Create<'a>> {
    if self.data_type() == Payload::Create {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Create::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_get(&self) -> Option<Get<'a>> {
    if self.data_type() == Payload::Get {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Get::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_values(&self) -> Option<Values<'a>> {
    if self.data_type() == Payload::Values {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Values::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_catalog(&self) -> Option<Catalog<'a>> {
    if self.data_type() == Payload::Catalog {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Catalog::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_register(&self) -> Option<Register<'a>> {
    if self.data_type() == Payload::Register {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Register::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Message<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Payload, _>("data_type", Self::VT_DATA_TYPE, "data", Self::VT_DATA, false, |key, v, pos| {
        match key {
          Payload::Create => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Create>>("Payload::Create", pos),
          Payload::Get => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Get>>("Payload::Get", pos),
          Payload::Values => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Values>>("Payload::Values", pos),
          Payload::Catalog => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Catalog>>("Payload::Catalog", pos),
          Payload::Register => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Register>>("Payload::Register", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<Status>>("status", Self::VT_STATUS, false)?
     .finish();
    Ok(())
  }
}
pub struct MessageArgs<'a> {
    pub data_type: Payload,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
}
impl<'a> Default for MessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    MessageArgs {
      data_type: Payload::NONE,
      data: None,
      status: None,
    }
  }
}

pub struct MessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data_type(&mut self, data_type: Payload) {
    self.fbb_.push_slot::<Payload>(Message::VT_DATA_TYPE, data_type, Payload::NONE);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_DATA, data);
  }
  #[inline]
  pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Status>>(Message::VT_STATUS, status);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Message<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Message");
      ds.field("data_type", &self.data_type());
      match self.data_type() {
        Payload::Create => {
          if let Some(x) = self.data_as_create() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Payload::Get => {
          if let Some(x) = self.data_as_get() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Payload::Values => {
          if let Some(x) = self.data_as_values() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Payload::Catalog => {
          if let Some(x) = self.data_as_catalog() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Payload::Register => {
          if let Some(x) = self.data_as_register() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("data", &x)
        },
      };
      ds.field("status", &self.status());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Message`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Message>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_message_unchecked`.
pub fn size_prefixed_root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Message>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Message` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn size_prefixed_root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Message`.
pub unsafe fn root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::root_unchecked::<Message>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Message`.
pub unsafe fn size_prefixed_root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::size_prefixed_root_unchecked::<Message>(buf)
}
#[inline]
pub fn finish_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod protocol

